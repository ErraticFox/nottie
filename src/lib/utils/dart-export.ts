// Dart Export utility
// Generates Dart/Flutter code for path animations

import type { AnimationState, PathCommand, Point, Keyframe, EasingType } from '$lib/types';

export function exportToDart(state: AnimationState): string {
	const className = 'NottieAnimation';
	const hasAnimation = state.keyframes.length >= 2;

	let code = `// Generated by Nottie - SVG Animation Tool
// Flutter Path Animation Code

import 'package:flutter/material.dart';

`;

	if (hasAnimation) {
		code += generateAnimatedPainter(state, className);
	} else {
		code += generateStaticPainter(state, className);
	}

	return code;
}

function generateStaticPainter(state: AnimationState, className: string): string {
	let code = `class ${className}Painter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final scaleX = size.width / ${state.width};
    final scaleY = size.height / ${state.height};
    canvas.scale(scaleX, scaleY);

`;

	state.layers.forEach((layer, layerIndex) => {
		if (!layer.visible) return;

		layer.paths.forEach((path, pathIndex) => {
			const varName = `path${layerIndex}_${pathIndex}`;
			code += `    // ${layer.name} - Path ${pathIndex + 1}\n`;
			code += generatePathCode(path.commands, varName);

			// Add paint
			code += `\n    final paint${layerIndex}_${pathIndex} = Paint()\n`;
			if (path.fill) {
				code += `      ..color = ${colorToDart(path.fill)}\n`;
				code += `      ..style = PaintingStyle.fill;\n`;
			} else if (path.stroke) {
				code += `      ..color = ${colorToDart(path.stroke)}\n`;
				code += `      ..style = PaintingStyle.stroke\n`;
				code += `      ..strokeWidth = ${path.strokeWidth || 1};\n`;
			} else {
				code += `      ..color = Colors.black\n`;
				code += `      ..style = PaintingStyle.stroke\n`;
				code += `      ..strokeWidth = 1;\n`;
			}
			code += `\n    canvas.drawPath(${varName}, paint${layerIndex}_${pathIndex});\n\n`;
		});
	});

	code += `  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}

// Usage example:
// CustomPaint(
//   size: Size(${state.width}, ${state.height}),
//   painter: ${className}Painter(),
// )
`;

	return code;
}

function generateAnimatedPainter(state: AnimationState, className: string): string {
	const duration = ((state.totalFrames / state.fps) * 1000).toFixed(0);

	let code = `class ${className} extends StatefulWidget {
  final double width;
  final double height;

  const ${className}({
    super.key,
    this.width = ${state.width},
    this.height = ${state.height},
  });

  @override
  State<${className}> createState() => _${className}State();
}

class _${className}State extends State<${className}> with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: ${duration}),
      vsync: this,
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return CustomPaint(
          size: Size(widget.width, widget.height),
          painter: ${className}Painter(
            progress: _controller.value,
          ),
        );
      },
    );
  }
}

class ${className}Painter extends CustomPainter {
  final double progress;

  ${className}Painter({required this.progress});

  @override
  void paint(Canvas canvas, Size size) {
    final scaleX = size.width / ${state.width};
    final scaleY = size.height / ${state.height};
    canvas.scale(scaleX, scaleY);

    final frame = (progress * ${state.totalFrames - 1}).round();

`;

	// Generate interpolation data for each path
	state.layers.forEach((layer, layerIndex) => {
		if (!layer.visible) return;

		layer.paths.forEach((path, pathIndex) => {
			const varName = `path${layerIndex}_${pathIndex}`;
			const keyframes = state.keyframes
				.filter((kf) => kf.pathSnapshots.has(path.id))
				.sort((a, b) => a.frame - b.frame);

			if (keyframes.length < 2) {
				// Static path
				code += `    // ${layer.name} - Path ${pathIndex + 1} (static)\n`;
				code += generatePathCode(path.commands, varName);
			} else {
				// Animated path
				code += `    // ${layer.name} - Path ${pathIndex + 1} (animated)\n`;
				code += generateAnimatedPathCode(path.id, keyframes, varName, state.totalFrames);
			}

			// Add paint
			code += `\n    final paint${layerIndex}_${pathIndex} = Paint()\n`;
			if (path.fill) {
				code += `      ..color = ${colorToDart(path.fill)}\n`;
				code += `      ..style = PaintingStyle.fill;\n`;
			} else if (path.stroke) {
				code += `      ..color = ${colorToDart(path.stroke)}\n`;
				code += `      ..style = PaintingStyle.stroke\n`;
				code += `      ..strokeWidth = ${path.strokeWidth || 1};\n`;
			} else {
				code += `      ..color = Colors.black\n`;
				code += `      ..style = PaintingStyle.stroke\n`;
				code += `      ..strokeWidth = 1;\n`;
			}
			code += `\n    canvas.drawPath(${varName}, paint${layerIndex}_${pathIndex});\n\n`;
		});
	});

	code += `  }

  @override
  bool shouldRepaint(covariant ${className}Painter oldDelegate) {
    return oldDelegate.progress != progress;
  }
}

// Usage example:
// ${className}(
//   width: ${state.width},
//   height: ${state.height},
// )
`;

	return code;
}

function generatePathCode(commands: PathCommand[], varName: string): string {
	let code = `    final ${varName} = Path()\n`;

	commands.forEach((cmd) => {
		switch (cmd.type) {
			case 'M':
				code += `      ..moveTo(${formatNum(cmd.points[0].x)}, ${formatNum(cmd.points[0].y)})\n`;
				break;
			case 'L':
				code += `      ..lineTo(${formatNum(cmd.points[0].x)}, ${formatNum(cmd.points[0].y)})\n`;
				break;
			case 'C':
				code += `      ..cubicTo(${formatNum(cmd.points[0].x)}, ${formatNum(cmd.points[0].y)}, ${formatNum(cmd.points[1].x)}, ${formatNum(cmd.points[1].y)}, ${formatNum(cmd.points[2].x)}, ${formatNum(cmd.points[2].y)})\n`;
				break;
			case 'Q':
				code += `      ..quadraticBezierTo(${formatNum(cmd.points[0].x)}, ${formatNum(cmd.points[0].y)}, ${formatNum(cmd.points[1].x)}, ${formatNum(cmd.points[1].y)})\n`;
				break;
			case 'Z':
				code += `      ..close()\n`;
				break;
		}
	});

	code = code.slice(0, -1) + ';\n'; // Remove last newline and add semicolon
	return code;
}

function generateAnimatedPathCode(
	pathId: string,
	keyframes: Keyframe[],
	varName: string,
	totalFrames: number
): string {
	let code = `    final ${varName} = _interpolatePath${varName}(frame);\n`;

	// Generate the interpolation function
	code += `\n  Path _interpolatePath${varName}(int frame) {\n`;

	// Generate keyframe data
	keyframes.forEach((kf, index) => {
		const snapshot = kf.pathSnapshots.get(pathId)!;
		code += `    // Keyframe at frame ${kf.frame}\n`;
		code += `    final kf${index}Commands = ${commandsToListLiteral(snapshot)};\n\n`;
	});

	// Generate interpolation logic
	code += `    // Find surrounding keyframes and interpolate\n`;

	for (let i = 0; i < keyframes.length - 1; i++) {
		const kf = keyframes[i];
		const nextKf = keyframes[i + 1];
		const condition = i === 0 ? `if` : `} else if`;

		code += `    ${condition} (frame >= ${kf.frame} && frame < ${nextKf.frame}) {\n`;
		code += `      final t = (frame - ${kf.frame}) / (${nextKf.frame} - ${kf.frame});\n`;
		code += `      final easedT = ${getEasingFunction(kf.easing)};\n`;
		code += `      return _lerpPath(kf${i}Commands, kf${i + 1}Commands, easedT);\n`;
	}

	// Handle frame at or after last keyframe
	code += `    } else {\n`;
	code += `      return _commandsToPath(kf${keyframes.length - 1}Commands);\n`;
	code += `    }\n`;
	code += `  }\n`;

	return code;
}

function commandsToListLiteral(commands: PathCommand[]): string {
	const items = commands.map((cmd) => {
		const points = cmd.points.map((p) => `[${formatNum(p.x)}, ${formatNum(p.y)}]`).join(', ');
		return `['${cmd.type}', [${points}]]`;
	});
	return `[${items.join(', ')}]`;
}

function getEasingFunction(easing: EasingType): string {
	switch (easing) {
		case 'ease-in':
			return 't * t';
		case 'ease-out':
			return 't * (2 - t)';
		case 'ease-in-out':
			return 't < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t';
		case 'linear':
		default:
			return 't';
	}
}

function colorToDart(color: string): string {
	const colorMap: Record<string, string> = {
		black: 'Colors.black',
		white: 'Colors.white',
		red: 'Colors.red',
		green: 'Colors.green',
		blue: 'Colors.blue',
		yellow: 'Colors.yellow',
		cyan: 'Colors.cyan',
		magenta: 'Colors.pink'
	};

	if (colorMap[color.toLowerCase()]) {
		return colorMap[color.toLowerCase()];
	}

	let hex = color;
	if (hex.startsWith('#')) {
		hex = hex.slice(1);
	}

	if (hex.length === 3) {
		hex = hex
			.split('')
			.map((c) => c + c)
			.join('');
	}

	return `const Color(0xFF${hex.toUpperCase()})`;
}

function formatNum(n: number): string {
	return Number.isInteger(n) ? `${n}.0` : n.toFixed(2);
}

export function downloadDart(code: string, filename: string = 'nottie_animation.dart') {
	const blob = new Blob([code], { type: 'text/plain' });

	const url = URL.createObjectURL(blob);
	const a = document.createElement('a');
	a.href = url;
	a.download = filename;
	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
	URL.revokeObjectURL(url);
}

// Helper functions that would be included in the generated Dart code
export const dartHelpers = `
  // Helper function to convert commands to a Path
  Path _commandsToPath(List<dynamic> commands) {
    final path = Path();
    for (final cmd in commands) {
      final type = cmd[0] as String;
      final points = cmd[1] as List<dynamic>;
      switch (type) {
        case 'M':
          path.moveTo(points[0][0], points[0][1]);
          break;
        case 'L':
          path.lineTo(points[0][0], points[0][1]);
          break;
        case 'C':
          path.cubicTo(
            points[0][0], points[0][1],
            points[1][0], points[1][1],
            points[2][0], points[2][1],
          );
          break;
        case 'Q':
          path.quadraticBezierTo(
            points[0][0], points[0][1],
            points[1][0], points[1][1],
          );
          break;
        case 'Z':
          path.close();
          break;
      }
    }
    return path;
  }

  // Helper function to interpolate between two paths
  Path _lerpPath(List<dynamic> from, List<dynamic> to, double t) {
    final path = Path();
    for (int i = 0; i < from.length && i < to.length; i++) {
      final fromCmd = from[i];
      final toCmd = to[i];
      final type = fromCmd[0] as String;
      final fromPoints = fromCmd[1] as List<dynamic>;
      final toPoints = toCmd[1] as List<dynamic>;

      switch (type) {
        case 'M':
          path.moveTo(
            _lerp(fromPoints[0][0], toPoints[0][0], t),
            _lerp(fromPoints[0][1], toPoints[0][1], t),
          );
          break;
        case 'L':
          path.lineTo(
            _lerp(fromPoints[0][0], toPoints[0][0], t),
            _lerp(fromPoints[0][1], toPoints[0][1], t),
          );
          break;
        case 'C':
          path.cubicTo(
            _lerp(fromPoints[0][0], toPoints[0][0], t),
            _lerp(fromPoints[0][1], toPoints[0][1], t),
            _lerp(fromPoints[1][0], toPoints[1][0], t),
            _lerp(fromPoints[1][1], toPoints[1][1], t),
            _lerp(fromPoints[2][0], toPoints[2][0], t),
            _lerp(fromPoints[2][1], toPoints[2][1], t),
          );
          break;
        case 'Q':
          path.quadraticBezierTo(
            _lerp(fromPoints[0][0], toPoints[0][0], t),
            _lerp(fromPoints[0][1], toPoints[0][1], t),
            _lerp(fromPoints[1][0], toPoints[1][0], t),
            _lerp(fromPoints[1][1], toPoints[1][1], t),
          );
          break;
        case 'Z':
          path.close();
          break;
      }
    }
    return path;
  }

  double _lerp(double a, double b, double t) => a + (b - a) * t;
`;
